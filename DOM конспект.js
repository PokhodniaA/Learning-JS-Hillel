// -------------Выбор элементов -----------

elem = document.getElementById('id') // поучить элемент по айди. Так же находяться и по другим свойствам. Если элементы, то возвращают живой список.

document.querySelector('css');
document.querySelectorAll('css') // Находим элементы по селектору css. Возвращает фиксированую колекцию.

elem.matches(css) //ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

elem.closest(css) //ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

elemA.contains(elemB) //вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

elem.getBoundingClientRect() //  возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.

/*Основные свойства объекта типа DOMRect:
    x/y – X/Y-координаты начала прямоугольника относительно окна,
    width/height – ширина/высота прямоугольника (могут быть отрицательными).
Дополнительные, «зависимые», свойства:
    top/bottom – Y-координата верхней/нижней границы прямоугольника,
    left/right – X-координата левой/правой границы прямоугольника.

    right = x + width
    bottom = y + height*/

document.elementFromPoint(x, y) //возвращает самый глубоко вложенный элемент в окне, находящийся по координатам (x, y).



// ---------------Модификация элементов --------------

elem.innerHTML // позволяет получить HTML-содержимое элемента в виде строки. получает содержимое всех элементов, включая  <script> и <style>, тогда как innerText этого не делает.

elem.data /*Свойство innerHTML есть только у узлов-элементов.
            У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и             data. Эти свойства очень похожи при использовании, есть лишь небольшие различия в           спецификации. Мы будем использовать data, потому что оно короче. */

elem.textContent //предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.

elem.hiden // действует так же, как и display:none;

/*У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

value – значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).

href – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).

id – значение атрибута «id» для всех элементов (HTMLElement). */

element.classList // Методы:(add, remove, toggle, replace). Для работы с классамы элементов. //element.classList.add('accent');

element.className // Возвращает классы для элемента

elem.innerText //умеет считывать стили и не возвращает содержимое скрытых элементов, тогда как textContent этого не делает

elem.style // Добавлять стили к эементу. css свойства пишуться camelCase-ом. 
//elem.style.fontSize


// ------------------Метрики------------------

elem.offsetParent //находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге.

elem.offsetLeft / elem.offsetTop //содержат координаты x/y относительно верхнего левого угла offsetParent.

elem.offsetWidth // внешняя ширина блока, её можно получить сложением CSS-ширины, внутренних отступов  и рамок.

elem.offsetHeight // внешняя высота блока.

elem.clientTop //ширина верхней рамки

elem.clientLeft // ширина левой рамки

elem.clientHeight // Горизонтальной прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота 200px плюс верхние и нижние внутренние отступы (2 * 20px), итого 240px.

elem.clientWidth // ширина содержимого здесь равна не 300px, а 284px, т.к. 16px отведено для полосы прокрутки. Таким образом: 284px плюс левый и правый отступы – всего 324px.

// Если нет внутренних отступов padding, то clientWidth/Height в точности равны размеру области содержимого внутри рамок и полосы прокрутки (если она есть).

elem.scrollHeight // полная внутренняя высота, включая прокрученную область.

elem.scrollWidth // полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна clientWidth.

elem.scrollLeft / elem.scrollTop // ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.


//  -----------------------EVENTS---------------

box.addEventListener('click', function () { }); // тоже что и on...

elem.onclick = function (event) { }; // Срабатывает при нажатии на элемент

elem.dblclick = function (event) { }; // Срабатывает при двойном нажатии на элемент

elem.onmousedown = function (event) { }; // Срабатывает при нажиминии ЛКМ на элемент, но не отпускании.

elem.onmouseup = function (event) { }; // Срабатывает при отпускании ЛКМ на элементе .

elem.onmousemove = function (event) { }; // Сраюатывает при движении мышки по элементу

elem.onmouseenter = function (event) { }; // Срабатывает при заходе мышки на элемент.Переходы внутри элемента, на его потомки и с них, не считаются.

elem.onmouseleave = function (event) { }; // Срабатывает при уходе мышки с элемента.Переходы внутри элемента, на его потомки и с них, не считаются.

elem.mouseover = function (event) { };
elem.mouseout = function (event) { }; // Курсор мыши появляется над элементом и уходит с него.

elem.contextmenu = function (event) { }; // Срабатывает при отпускании ПКМ на элементе .

elem.onchange = function () { }; // change срабатывает по окончании изменения элемента. Для текстовых <input> это означает, что событие происходит при потере фокуса.

elem.oninput = function () { }; //input срабатывает каждый раз при изменении значения.

elem.oncopy = function () { }; // при копировании

elem.onpaste = function () { }; // при вставливании

elem.oncut = function () { }; // при вырезании

// ---------event------------

// event.preventDefault() -- убрать действия по умолчанию


// event.which -- События, связанные с кликом, всегда имеют свойство which, которое     позволяет определить нажатую кнопку мыши. Есть три возможных значения:
                // event.which == 1 – левая кнопка
                // event.which == 2 – средняя кнопка
                // event.which == 3 – правая кнопка


// event.altKey -- добавить модификаторы кнопок.
/*Свойства объекта события:
    shiftKey: Shift
    altKey: Alt (или Opt для Mac)
    ctrlKey: Ctrl
    metaKey: Cmd для Mac */

// event.clientX / .clientY --  позиция относительно окна.

// event.pageX / .pageY --  позиция относительно документа.

// Для события mouseover:
    // event.target -- это элемент, на который курсор перешёл.
    // event.relatedTarget –- это элемент, с которого курсор ушёл (relatedTarget → target).

// Для события mouseout наоборот:
    //event.target –- это элемент, с которого курсор ушёл.
    // event.relatedTarget –- это элемент, на который курсор перешёл (target → relatedTarget).

